
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>EE 125 Matlab 4 Part 2: Signal Compression</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-11-05"><meta name="DC.source" content="EE125_Matlab4_Part2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>EE 125 Matlab 4 Part 2: Signal Compression</h1><!--introduction--><p>Section 1: FFT Compression Section 2: Storage savings due to compression Section 3: Discrete cosine transform</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">FFT Compression</a></li><li><a href="#2">Storage savings due to compression</a></li><li><a href="#3">Discrete Cosine Transform</a></li></ul></div><h2 id="1">FFT Compression</h2><pre class="codeinput"><span class="comment">% Step 1</span>
<span class="comment">% Loading the train file</span>
load <span class="string">train</span>

<span class="comment">% Listening to the train file</span>
<span class="comment">% soundsc(y,Fs)</span>

<span class="comment">% Step 2</span>
<span class="comment">% Take the N pt FFT using the next highest power of 2 from length(y) for N</span>
n = 2^nextpow2(length(y));
f = Fs*(0:(n/2))/n;
Y = fft(y,n);

<span class="comment">% Convert to decibels</span>
P = mag2db(abs(Y));

figure(3)
plot(f,P(1:n/2+1))
xlabel(<span class="string">'f (Hz)'</span>)
ylabel(<span class="string">'|P(f)|, dB'</span>)
title(<span class="string">'Signal Power vs. Frequency'</span>)

<span class="comment">% The signal has its most powerful components at 750, 900, 1100, 2100,</span>
<span class="comment">% 2700, and 3500 Hz. If you look at the euler decomposition of the Fourier</span>
<span class="comment">% transform this means the signal is primarily composed of cosines of those</span>
<span class="comment">% frequencies</span>

<span class="comment">% Step 3</span>
<span class="comment">% Print the FFTcompression function</span>
type(<span class="string">'FFTcompression.m'</span>)

<span class="comment">% Step 4</span>
type(<span class="string">'SNRoverall.m'</span>)

<span class="comment">% Step 5</span>
<span class="comment">% Compress using FFT</span>
Y100 = FFTcompression(y,100);
Y50 = FFTcompression(y,50);
Y20 = FFTcompression(y,20);
Y10 = FFTcompression(y,10);

<span class="comment">% Reconstruct in time domain</span>
recon100 = ifft(Y100);
recon50 = ifft(Y50);
recon20 = ifft(Y20);
recon10 = ifft(Y10);

<span class="comment">% Step 5 a</span>
<span class="comment">% Listen to the different sounds</span>
<span class="comment">% soundsc(recon100,Fs) % Sounds like the normal signal</span>
<span class="comment">% soundsc(recon50,Fs) % Sounds pretty good, but not quite the same</span>
<span class="comment">% soundsc(recon20,Fs) % Not terribly different from 50% but not amazing</span>
<span class="comment">% soundsc(recon10,Fs) % Not great quality but definitely still sounds like</span>
<span class="comment">% a train.</span>
<span class="comment">% I did some testing in the command window to try to find where I could</span>
<span class="comment">% stop recognizing the signal and I found that to be at about 0.25 percent</span>
<span class="comment">% retained, which I found really surprising (I was expecting to not be able</span>
<span class="comment">% to remove such a high percentage of the original signal), I could even</span>
<span class="comment">% kind of recognize it at 0.1%.</span>

<span class="comment">% Step 5 b</span>
<span class="comment">% Plot the original magnitude spectrum and the 10% spectrum together</span>
P10 = mag2db(abs(Y10));
P10(P10&lt;-10^6) = 0;
figure(4)
plot(f,P(1:n/2+1),<span class="string">'b'</span>,f,P10(1:n/2+1),<span class="string">'r'</span>)
xlabel(<span class="string">'f (Hz)'</span>)
ylabel(<span class="string">'|P(f)|, dB'</span>)
title(<span class="string">'Original spectrum and 10% spectrum compared'</span>)
legend(<span class="string">'Original'</span>,<span class="string">'10%'</span>)
<span class="comment">% The unadulterated signal is much more organic because its composed of a</span>
<span class="comment">% much larger variety of sinusoids where the 10% sounds fake because it's</span>
<span class="comment">% made up of less harmonics.</span>

<span class="comment">% Step 5 c</span>
yp = ifft(Y); <span class="comment">% Just doing this to preserve the signal length</span>
snr100 = SNRoverall(yp,recon100);
snr50 = SNRoverall(yp,recon50);
snr20 = SNRoverall(yp,recon20);
snr10 = SNRoverall(yp,recon10);

T = table(snr100,snr50,snr20,snr10)

<span class="comment">% Step 6</span>
clear
[y,Fs] = audioread(<span class="string">'onscreen.wav'</span>);

<span class="comment">% Compress using FFT</span>
Y100 = FFTcompression(y,100);
Y50 = FFTcompression(y,50);
Y20 = FFTcompression(y,20);
Y10 = FFTcompression(y,10);

<span class="comment">% Reconstruct in time domain</span>
recon100 = ifft(Y100);
recon50 = ifft(Y50);
recon20 = ifft(Y20);
recon10 = ifft(Y10);

<span class="comment">% Listening to the outputs</span>
<span class="comment">% soundsc(recon100,Fs) % Sounds like the normal signal</span>
<span class="comment">% soundsc(recon50,Fs) % Sounds pretty good, guys voice sounds shallower</span>
<span class="comment">% soundsc(recon20,Fs) % The guy sounds like he's speaking through an</span>
<span class="comment">% intercom</span>
<span class="comment">% soundsc(recon10,Fs) % The guy sounds even more fake, like a textbook</span>
<span class="comment">% example of a digital recording</span>
<span class="comment">% This compression works until just about 2 percent when you start to</span>
<span class="comment">% barely be able to understand what is being said</span>

<span class="comment">% Plot the original magnitude spectrum and the 10% spectrum together</span>
n = 2^nextpow2(length(y));
f = Fs*(0:(n/2))/n;
Y = fft(y,n);
P = mag2db(abs(Y));
P10 = mag2db(abs(Y10));
P10(P10&lt;-10^6) = 0;
figure(4)
plot(f,P(1:n/2+1),<span class="string">'b'</span>,f,P10(1:n/2+1),<span class="string">'r'</span>)
xlabel(<span class="string">'f (Hz)'</span>)
ylabel(<span class="string">'|P(f)|, dB'</span>)
title(<span class="string">'Original spectrum and 10% spectrum compared'</span>)
legend(<span class="string">'Original'</span>,<span class="string">'10%'</span>)
<span class="comment">% Looking at the graph it makes sense why you can still understand what he</span>
<span class="comment">% is saying even when retaining only 10 percent of the signal power. This</span>
<span class="comment">% is because you can see the frequency waveforms for the important things</span>
<span class="comment">% he says like "on screen" and the beep or whatever that is.</span>

<span class="comment">% Calculating the SNR values</span>
yp = ifft(Y); <span class="comment">% Just doing this to preserve the signal length</span>
snr100 = SNRoverall(yp,recon100);
snr50 = SNRoverall(yp,recon50);
snr20 = SNRoverall(yp,recon20);
snr10 = SNRoverall(yp,recon10);

T = table(snr100,snr50,snr20,snr10)
</pre><pre class="codeoutput">
function Yout = FFTcompression(signal,percentRetained)
% function Yout = FFTcompression(signal,percentRetained)
% This function takes in a signal and a percent of the signal to retain,
% computes the fourier transform and removes the undesired components, and
% returns the FFT of only the percent you want to keep.
% If the percent retained is 90, then the top 90% of the signal will be
% kept.

% Take the Fourier transform
n = 2^nextpow2(length(signal));
S = fft(signal,n);

% Zero out the weaker frequency components and return the signal
dummy = sort(abs(S));
index = round((1-percentRetained/100)*length(dummy))+1;
q = dummy(index);
S(abs(S)&lt;=q) = 0;
Yout = S;

return

function snr = SNRoverall(signal,reconSignal)
% function snr = SNRoverall(signal,reconSignal)
% This function computes the overall SNR of a signal

snr = 10*log(sum(signal.^2./(signal-reconSignal).^2));

return

T = 

    snr100    snr50     snr20    snr10 
    ______    ______    _____    ______

    448.61    289.98    300.5    274.96


T = 

    snr100    snr50     snr20     snr10
    ______    ______    ______    _____

    477.95    239.07    231.94    271.2

</pre><img vspace="5" hspace="5" src="EE125_Matlab4_Part2_01.png" alt=""> <img vspace="5" hspace="5" src="EE125_Matlab4_Part2_02.png" alt=""> <h2 id="2">Storage savings due to compression</h2><p>Step 1 It makes sense that the Fourier transform is doubling storage space of the signal because the FFT returns the information in both the positive and negative frequencies. If I were going to save them, since I know the original signal will always be real valued, I would save only half of the Fourier transform because the negative frequencies are going to be symmetric to the positive frequencies about the y axis. If you look at the length adjusted yp, then the amount of data is going to be the same whether it is stored in the Fourier or time domain (if you take only one half of Fourier data). This would equate to the same amount of memory usage storing data in the time or frequency domain assuming you make the signal to the next power of 2</p><pre class="codeinput">whos <span class="string">y</span>
whos <span class="string">yp</span>
whos <span class="string">Y</span>
whos <span class="string">Y100</span>
<span class="comment">% whos Y50</span>
<span class="comment">% whos Y20</span>
whos <span class="string">Y10</span>

<span class="comment">% Step 2</span>
Ysp = sparse(Y10);
whos <span class="string">Ysp</span> <span class="comment">% Oh wow, Y10 is 524288 bytes where Ysp is 78616 bytes.</span>
<span class="comment">% The space saving here is pretty substantial, but not 10x. This is</span>
<span class="comment">% probably because the array still needs to save the corresponding</span>
<span class="comment">% positions for each of the nonzero values from the previous matrix. Instead</span>
<span class="comment">% of just storing all of the values and keeping the zeros in the places</span>
<span class="comment">% they were in before you have to store all the position values of the</span>
<span class="comment">% nonzero values.</span>
</pre><pre class="codeoutput">  Name          Size             Bytes  Class     Attributes

  y         25680x1             205440  double              

  Name          Size             Bytes  Class     Attributes

  yp        32768x1             262144  double              

  Name          Size             Bytes  Class     Attributes

  Y         32768x1             524288  double    complex   

  Name          Size             Bytes  Class     Attributes

  Y100      32768x1             524288  double    complex   

  Name          Size             Bytes  Class     Attributes

  Y10       32768x1             524288  double    complex   

  Name          Size            Bytes  Class     Attributes     

  Ysp       32768x1             78616  double    sparse, complex

</pre><h2 id="3">Discrete Cosine Transform</h2><pre class="codeinput"><span class="comment">% Step 1</span>
D = zeros(1024,1);

D(1) = 1;
d = idct(D);
figure(5)
subplot <span class="string">311</span>
plot(d)
axis([0 1024 -0.05 0.05])
xlabel(<span class="string">'sample number'</span>)
ylabel(<span class="string">'d'</span>)
title(<span class="string">'D(1) = 1'</span>)

D(1) = 0;
D(2) = 1;
d = idct(D);
subplot <span class="string">312</span>
plot(d)
axis([0 1024 -0.05 0.05])
xlabel(<span class="string">'sample number'</span>)
ylabel(<span class="string">'d'</span>)
title(<span class="string">'D(2) = 1'</span>)

D(2) = 0;
D(3) = 1;
d = idct(D);
subplot <span class="string">313</span>
plot(d)
axis([0 1024 -0.05 0.05])
xlabel(<span class="string">'sample number'</span>)
ylabel(<span class="string">'d'</span>)
title(<span class="string">'D(3) = 1'</span>)

suptitle(<span class="string">'Varying which position is nonzero, in DCT domain'</span>)

<span class="comment">% What this step is doing is varying which composite harmonics are being</span>
<span class="comment">% represented in the signal. The discrete cosine transformation represents</span>
<span class="comment">% a time domain signal as a composite superposition of a bunch of different</span>
<span class="comment">% cosine functions. When you set D(1) = 1 you're setting the magnitude for</span>
<span class="comment">% what is the DC component of the signal. When you set D(2) = 1 you're</span>
<span class="comment">% looking at only the first harmonic (lowest nonzero frequency), and when</span>
<span class="comment">% you set D(3) = 1 you're looking at the next harmonic. The results make</span>
<span class="comment">% sense since the first plot is just a DC shift, the second plot is a</span>
<span class="comment">% cosine, and the third plot is a higher frequency cosine.</span>

<span class="comment">% Step 2</span>
type(<span class="string">'DCTcompression.m'</span>)

D100 = DCTcompression(y,100);
D50 = DCTcompression(y,50);
D20 = DCTcompression(y,20);
D10 = DCTcompression(y,10);

dctRecon100 = idct(D100);
dctRecon50 = idct(D50);
dctRecon20 = idct(D20);
dctRecon10 = idct(D10);

dctSnr100 = SNRoverall(yp,dctRecon100);
dctSnr50 = SNRoverall(yp,dctRecon50);
dctSnr20 = SNRoverall(yp,dctRecon20);
dctSnr10 = SNRoverall(yp,dctRecon10);

<span class="comment">% DCT SNR table</span>
dctT = table(dctSnr100,dctSnr50,dctSnr20,dctSnr10)

<span class="comment">% Listening to the differences between FFT, DCT compressions, 20% retained</span>
<span class="comment">% soundsc(recon20,Fs)</span>
<span class="comment">% soundsc(dctRecon20,Fs)</span>
<span class="comment">% Oh wow, I actually found there to be a kind of significant difference in</span>
<span class="comment">% the amount of noise you hear in the reconstructed signal. The DCT was</span>
<span class="comment">% much cleaner.</span>
</pre><pre class="codeoutput">
function Dout = DCTcompression(signal,percentRetained)
% function Dout = DCTcompression(signal,percentRetained)
% This function takes in a time domain signal, performs a DCT, retaining
% only a desired percentage of the signal strength.

% Take the n point DCT of the function (making sure it's an even power of
% 2)
n = 2^nextpow2(length(signal));
D = dct(signal,n);

% Find where you want to start zeroing out data
dummy = sort(abs(D));
index = round((1-percentRetained/100)*length(dummy)) + 1;

% Zero out the desired data points
Dout = D;
Dout(abs(Dout)&lt;dummy(index)) = 0;

return

dctT = 

    dctSnr100    dctSnr50    dctSnr20    dctSnr10
    _________    ________    ________    ________

    NaN          298.61      278.77      210.38  

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% EE 125 Matlab 4 Part 2: Signal Compression
% Section 1: FFT Compression
% Section 2: Storage savings due to compression
% Section 3: Discrete cosine transform

%% FFT Compression

% Step 1
% Loading the train file
load train

% Listening to the train file
% soundsc(y,Fs)

% Step 2
% Take the N pt FFT using the next highest power of 2 from length(y) for N
n = 2^nextpow2(length(y));
f = Fs*(0:(n/2))/n;
Y = fft(y,n);

% Convert to decibels
P = mag2db(abs(Y));

figure(3)
plot(f,P(1:n/2+1))
xlabel('f (Hz)')
ylabel('|P(f)|, dB')
title('Signal Power vs. Frequency')

% The signal has its most powerful components at 750, 900, 1100, 2100,
% 2700, and 3500 Hz. If you look at the euler decomposition of the Fourier
% transform this means the signal is primarily composed of cosines of those
% frequencies

% Step 3
% Print the FFTcompression function
type('FFTcompression.m')

% Step 4
type('SNRoverall.m')

% Step 5
% Compress using FFT
Y100 = FFTcompression(y,100);
Y50 = FFTcompression(y,50);
Y20 = FFTcompression(y,20);
Y10 = FFTcompression(y,10);

% Reconstruct in time domain
recon100 = ifft(Y100);
recon50 = ifft(Y50);
recon20 = ifft(Y20);
recon10 = ifft(Y10);

% Step 5 a
% Listen to the different sounds
% soundsc(recon100,Fs) % Sounds like the normal signal
% soundsc(recon50,Fs) % Sounds pretty good, but not quite the same
% soundsc(recon20,Fs) % Not terribly different from 50% but not amazing
% soundsc(recon10,Fs) % Not great quality but definitely still sounds like
% a train.
% I did some testing in the command window to try to find where I could
% stop recognizing the signal and I found that to be at about 0.25 percent
% retained, which I found really surprising (I was expecting to not be able
% to remove such a high percentage of the original signal), I could even
% kind of recognize it at 0.1%.

% Step 5 b
% Plot the original magnitude spectrum and the 10% spectrum together
P10 = mag2db(abs(Y10));
P10(P10<-10^6) = 0;
figure(4)
plot(f,P(1:n/2+1),'b',f,P10(1:n/2+1),'r')
xlabel('f (Hz)')
ylabel('|P(f)|, dB')
title('Original spectrum and 10% spectrum compared')
legend('Original','10%')
% The unadulterated signal is much more organic because its composed of a
% much larger variety of sinusoids where the 10% sounds fake because it's
% made up of less harmonics.

% Step 5 c
yp = ifft(Y); % Just doing this to preserve the signal length
snr100 = SNRoverall(yp,recon100);
snr50 = SNRoverall(yp,recon50);
snr20 = SNRoverall(yp,recon20);
snr10 = SNRoverall(yp,recon10);

T = table(snr100,snr50,snr20,snr10)

% Step 6
clear
[y,Fs] = audioread('onscreen.wav');

% Compress using FFT
Y100 = FFTcompression(y,100);
Y50 = FFTcompression(y,50);
Y20 = FFTcompression(y,20);
Y10 = FFTcompression(y,10);

% Reconstruct in time domain
recon100 = ifft(Y100);
recon50 = ifft(Y50);
recon20 = ifft(Y20);
recon10 = ifft(Y10);

% Listening to the outputs
% soundsc(recon100,Fs) % Sounds like the normal signal
% soundsc(recon50,Fs) % Sounds pretty good, guys voice sounds shallower
% soundsc(recon20,Fs) % The guy sounds like he's speaking through an
% intercom
% soundsc(recon10,Fs) % The guy sounds even more fake, like a textbook
% example of a digital recording
% This compression works until just about 2 percent when you start to
% barely be able to understand what is being said

% Plot the original magnitude spectrum and the 10% spectrum together
n = 2^nextpow2(length(y));
f = Fs*(0:(n/2))/n;
Y = fft(y,n);
P = mag2db(abs(Y));
P10 = mag2db(abs(Y10));
P10(P10<-10^6) = 0;
figure(4)
plot(f,P(1:n/2+1),'b',f,P10(1:n/2+1),'r')
xlabel('f (Hz)')
ylabel('|P(f)|, dB')
title('Original spectrum and 10% spectrum compared')
legend('Original','10%')
% Looking at the graph it makes sense why you can still understand what he
% is saying even when retaining only 10 percent of the signal power. This
% is because you can see the frequency waveforms for the important things
% he says like "on screen" and the beep or whatever that is.

% Calculating the SNR values
yp = ifft(Y); % Just doing this to preserve the signal length
snr100 = SNRoverall(yp,recon100);
snr50 = SNRoverall(yp,recon50);
snr20 = SNRoverall(yp,recon20);
snr10 = SNRoverall(yp,recon10);

T = table(snr100,snr50,snr20,snr10)

%% Storage savings due to compression
% Step 1
% It makes sense that the Fourier transform is doubling storage space of
% the signal because the FFT returns the information in both the positive
% and negative frequencies. If I were going to save them, since I know the
% original signal will always be real valued, I would save only half of the
% Fourier transform because the negative frequencies are going to be
% symmetric to the positive frequencies about the y axis. If you look at
% the length adjusted yp, then the amount of data is going to be the same
% whether it is stored in the Fourier or time domain (if you take only one
% half of Fourier data). This would equate to the same amount of memory
% usage storing data in the time or frequency domain assuming you make the
% signal to the next power of 2
whos y
whos yp
whos Y
whos Y100
% whos Y50
% whos Y20
whos Y10

% Step 2
Ysp = sparse(Y10);
whos Ysp % Oh wow, Y10 is 524288 bytes where Ysp is 78616 bytes.
% The space saving here is pretty substantial, but not 10x. This is
% probably because the array still needs to save the corresponding
% positions for each of the nonzero values from the previous matrix. Instead
% of just storing all of the values and keeping the zeros in the places
% they were in before you have to store all the position values of the
% nonzero values.

%% Discrete Cosine Transform

% Step 1
D = zeros(1024,1);

D(1) = 1;
d = idct(D);
figure(5)
subplot 311
plot(d)
axis([0 1024 -0.05 0.05])
xlabel('sample number')
ylabel('d')
title('D(1) = 1')

D(1) = 0;
D(2) = 1;
d = idct(D);
subplot 312
plot(d)
axis([0 1024 -0.05 0.05])
xlabel('sample number')
ylabel('d')
title('D(2) = 1')

D(2) = 0;
D(3) = 1;
d = idct(D);
subplot 313
plot(d)
axis([0 1024 -0.05 0.05])
xlabel('sample number')
ylabel('d')
title('D(3) = 1')

suptitle('Varying which position is nonzero, in DCT domain')

% What this step is doing is varying which composite harmonics are being
% represented in the signal. The discrete cosine transformation represents
% a time domain signal as a composite superposition of a bunch of different
% cosine functions. When you set D(1) = 1 you're setting the magnitude for
% what is the DC component of the signal. When you set D(2) = 1 you're
% looking at only the first harmonic (lowest nonzero frequency), and when
% you set D(3) = 1 you're looking at the next harmonic. The results make
% sense since the first plot is just a DC shift, the second plot is a
% cosine, and the third plot is a higher frequency cosine.

% Step 2
type('DCTcompression.m')

D100 = DCTcompression(y,100);
D50 = DCTcompression(y,50);
D20 = DCTcompression(y,20);
D10 = DCTcompression(y,10);

dctRecon100 = idct(D100);
dctRecon50 = idct(D50);
dctRecon20 = idct(D20);
dctRecon10 = idct(D10);

dctSnr100 = SNRoverall(yp,dctRecon100);
dctSnr50 = SNRoverall(yp,dctRecon50);
dctSnr20 = SNRoverall(yp,dctRecon20);
dctSnr10 = SNRoverall(yp,dctRecon10);

% DCT SNR table
dctT = table(dctSnr100,dctSnr50,dctSnr20,dctSnr10)

% Listening to the differences between FFT, DCT compressions, 20% retained
% soundsc(recon20,Fs)
% soundsc(dctRecon20,Fs)
% Oh wow, I actually found there to be a kind of significant difference in
% the amount of noise you hear in the reconstructed signal. The DCT was
% much cleaner.
##### SOURCE END #####
--></body></html>